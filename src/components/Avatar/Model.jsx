/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 model.glb
*/

import React, { useRef, useState, useMemo, useEffect } from 'react'
import { useGLTF, useTexture, Loader, Environment, useFBX, useAnimations, OrthographicCamera } from '@react-three/drei'
import { MeshStandardMaterial } from 'three/src/materials/MeshStandardMaterial';

import { InternalApi } from '../../services/internalApi';

import { useFrame } from '@react-three/fiber';

import { Storage } from '../../data/storage';

import * as THREE from 'three';

import { LinearEncoding, sRGBEncoding } from 'three/src/constants';
import { LineBasicMaterial, MeshPhysicalMaterial, Vector2 } from 'three';

import { createAnimation, createAnimationFromInternal } from './converter';
import blinkData from './blendDataBlink.json';

import { TextToSpeechService } from '../../services/textToSpeechService';

const lodash = require('lodash');


export function Suzanne(props) {
  const {
    speak,
    setSpeak,
    text,
    setAudioSource,
    playing,
  } = props;

  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/model.glb');
  const { actions } = useAnimations(animations, group)

  let morphTargetDictionaryBody = null;
  let morphTargetDictionaryLowerTeeth = null;

  const storageService = new Storage();

  const internalApi = new InternalApi();

  const [
    bodyTexture,
    eyesTexture,
    teethTexture,
    bodySpecularTexture,
    bodyRoughnessTexture,
    bodyNormalTexture,
    teethNormalTexture,
    hairTexture,
    tshirtDiffuseTexture,
    tshirtNormalTexture,
    tshirtRoughnessTexture,
    hairAlphaTexture,
    hairNormalTexture,
    hairRoughnessTexture,
  ] = useTexture([
    "/images/body.webp",
    "/images/eyes.webp",
    "/images/teeth_diffuse.webp",
    "/images/body_specular.webp",
    "/images/body_roughness.webp",
    "/images/body_normal.webp",
    "/images/teeth_normal.webp",
    // "/images/teeth_specular.webp",
    "/images/h_color.webp",
    "/images/tshirt_diffuse.webp",
    "/images/tshirt_normal.webp",
    "/images/tshirt_roughness.webp",
    "/images/h_alpha.webp",
    "/images/h_normal.webp",
    "/images/h_roughness.webp",
  ]);

  lodash.each([
    bodyTexture,
    eyesTexture,
    teethTexture,
    teethNormalTexture,
    bodySpecularTexture,
    bodyRoughnessTexture,
    bodyNormalTexture,
    tshirtDiffuseTexture,
    tshirtNormalTexture,
    tshirtRoughnessTexture,
    hairAlphaTexture,
    hairNormalTexture,
    hairRoughnessTexture
  ], t => {
    t.encoding = sRGBEncoding;
    t.flipY = false;
  });

  bodyNormalTexture.encoding = LinearEncoding;
  tshirtNormalTexture.encoding = LinearEncoding;
  teethNormalTexture.encoding = LinearEncoding;
  hairNormalTexture.encoding = LinearEncoding;

  nodes.Scene.traverse(node => {
    if (node.type === 'Mesh' || node.type === 'LineSegments' || node.type === 'SkinnedMesh') {

      node.castShadow = true;
      node.receiveShadow = true;
      node.frustumCulled = false;


      if (node.name.includes("Body")) {

        node.castShadow = true;
        node.receiveShadow = true;

        node.material = new MeshPhysicalMaterial();
        node.material.map = bodyTexture;
        node.material.shininess = 60;
        node.material.roughness = 1.7;

        // node.material.specularMap = bodySpecularTexture;
        node.material.roughnessMap = bodyRoughnessTexture;
        node.material.normalMap = bodyNormalTexture;
        node.material.normalScale = new Vector2(0.6, 0.6);

        morphTargetDictionaryBody = node.morphTargetDictionary;

        node.material.envMapIntensity = 0.8;
        // node.material.visible = false;

      }

      if (node.name.includes("Eyes")) {
        node.material = new MeshStandardMaterial();
        node.material.map = eyesTexture;
        // node.material.shininess = 100;
        node.material.roughness = 0.1;
        node.material.envMapIntensity = 0.5;


      }

      if (node.name.includes("Brows")) {
        node.material = new LineBasicMaterial({ color: 0x000000 });
        node.material.linewidth = 1;
        node.material.opacity = 0.5;
        node.material.transparent = true;
        node.visible = false;
      }

      if (node.name.includes("Teeth")) {

        node.receiveShadow = true;
        node.castShadow = true;
        node.material = new MeshStandardMaterial();
        node.material.roughness = 0.1;
        node.material.map = teethTexture;
        node.material.normalMap = teethNormalTexture;

        node.material.envMapIntensity = 0.7;


      }

      if (node.name.includes("Hair")) {
        node.material = new MeshStandardMaterial();
        node.material.map = hairTexture;
        node.material.alphaMap = hairAlphaTexture;
        node.material.normalMap = hairNormalTexture;
        node.material.roughnessMap = hairRoughnessTexture;

        node.material.transparent = true;
        node.material.depthWrite = false;
        node.material.side = 2;
        node.material.color.setHex(0x000000);

        node.material.envMapIntensity = 0.3;


      }

      if (node.name.includes("TSHIRT")) {
        node.material = new MeshStandardMaterial();

        node.material.map = tshirtDiffuseTexture;
        node.material.roughnessMap = tshirtRoughnessTexture;
        node.material.normalMap = tshirtNormalTexture;
        node.material.color.setHex(0xffffff);

        node.material.envMapIntensity = 0.5;


      }

      if (node.name.includes("TeethLower")) {
        morphTargetDictionaryLowerTeeth = node.morphTargetDictionary;
      }
    }
  });

  const [clips, setClips] = useState([]);
  const mixer = useMemo(() => new THREE.AnimationMixer(nodes.Scene), []);

  useEffect(() => {

    if (speak === false)
      return;

      
      internalApi.getAvatarSpeech(text)
      .then((visemeResponse) => {
        const fileResponse = visemeResponse.fileResponse;
        const visemes = visemeResponse.visemes;

        let newClips = [
          createAnimationFromInternal(visemes, morphTargetDictionaryBody, 'HG_Body', true),
          createAnimationFromInternal(visemes, morphTargetDictionaryLowerTeeth, 'HG_TeethLower', true)
        ];

        // lodash.each(newClips, clip => {
        //   let clipAction = mixer.clipAction(clip);
        //   clipAction.setLoop(THREE.LoopOnce);
        //   clipAction.play();
        // });

        storageService._getDownloadURL(fileResponse.filename).then((downloadUrl) => {
          setClips(newClips);
          setAudioSource(downloadUrl);
        });
      });
  }, [speak]);

  let idleFbx = useFBX('/idle.fbx');
  let { clips: idleClips } = useAnimations(idleFbx.animations);

  idleClips[0].tracks = lodash.filter(idleClips[0].tracks, track => {
    return track.name.includes("Head") || track.name.includes("Neck") || track.name.includes("Spine2");
  });

  idleClips[0].tracks = lodash.map(idleClips[0].tracks, track => {

    if (track.name.includes("Head")) {
      track.name = "head.quaternion";
    }

    if (track.name.includes("Neck")) {
      track.name = "neck.quaternion";
    }

    if (track.name.includes("Spine")) {
      track.name = "spine2.quaternion";
    }

    return track;

  });

  useEffect(() => {

    let idleClipAction = mixer.clipAction(idleClips[0]);
    idleClipAction.play();

    let blinkClip = createAnimation(blinkData, morphTargetDictionaryBody, 'HG_Body');
    let blinkAction = mixer.clipAction(blinkClip);
    blinkAction.play();


  }, []);

  // Play animation clips when available
  useEffect(() => {

    if (playing === false)
      return;

    lodash.each(clips, clip => {
      let clipAction = mixer.clipAction(clip);
      clipAction.setLoop(THREE.LoopOnce);
      clipAction.play();

    });

  }, [playing]);

  useFrame((state, delta) => {
    mixer.update(delta);
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="HG_Lula">
          <primitive object={nodes.spine} />
          <skinnedMesh name="HG_Eyes" geometry={nodes.HG_Eyes.geometry} material={nodes.HG_Eyes.material} skeleton={nodes.HG_Eyes.skeleton} />
          <skinnedMesh name="HG_TeethUpper" geometry={nodes.HG_TeethUpper.geometry} material={nodes.HG_TeethUpper.material} skeleton={nodes.HG_TeethUpper.skeleton} />
          <skinnedMesh name="HG_TeethLower" geometry={nodes.HG_TeethLower.geometry} material={nodes.HG_TeethLower.material} skeleton={nodes.HG_TeethLower.skeleton} morphTargetDictionary={nodes.HG_TeethLower.morphTargetDictionary} morphTargetInfluences={nodes.HG_TeethLower.morphTargetInfluences} />
          <skinnedMesh name="HG_Body" geometry={nodes.HG_Body.geometry} material={nodes.HG_Body.material} skeleton={nodes.HG_Body.skeleton} morphTargetDictionary={nodes.HG_Body.morphTargetDictionary} morphTargetInfluences={nodes.HG_Body.morphTargetInfluences} />
          <skinnedMesh name="HG_Skinny_Jeans_Female001" geometry={nodes.HG_Skinny_Jeans_Female001.geometry} material={nodes.HG_Skinny_Jeans_Female001.material} skeleton={nodes.HG_Skinny_Jeans_Female001.skeleton} morphTargetDictionary={nodes.HG_Skinny_Jeans_Female001.morphTargetDictionary} morphTargetInfluences={nodes.HG_Skinny_Jeans_Female001.morphTargetInfluences} />
          <skinnedMesh name="HG_TSHIRT_Female001" geometry={nodes.HG_TSHIRT_Female001.geometry} material={nodes.HG_TSHIRT_Female001.material} skeleton={nodes.HG_TSHIRT_Female001.skeleton} morphTargetDictionary={nodes.HG_TSHIRT_Female001.morphTargetDictionary} morphTargetInfluences={nodes.HG_TSHIRT_Female001.morphTargetInfluences} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/model.glb')
